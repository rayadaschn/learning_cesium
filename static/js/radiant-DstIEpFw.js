import{b as e,h as n,_ as a,u as t,d as r,r as o,o as i,c as s,a as u,w as c,f as C,g as l}from"./index-DVefKlEl.js";const m={class:"container"},d=a({__name:"radiant",setup(a){const d=t().viewer,{add:p,clear:v}=function(a){const t=e([]),r=()=>{t.value.forEach((e=>{a.scene.postProcessStages.remove(e)})),t.value=[]},o=(e,n,a,t)=>{const r=new Cesium.Cartographic(Cesium.Math.toRadians(e[0]),Cesium.Math.toRadians(e[1]),e[2]),o=Cesium.Color.fromCssColorString(n);return i(r,a,o,t)},i=(e,n,t,r)=>{const o=Cesium.Cartographic.toCartesian(e),i=new Cesium.Cartesian4(o.x,o.y,o.z,1),u=new Cesium.Cartographic(e.longitude,e.latitude,e.height+500),c=Cesium.Cartographic.toCartesian(u),C=new Cesium.Cartesian4(c.x,c.y,c.z,1),l=Date.now(),m=new Cesium.Cartesian4,d=new Cesium.Cartesian4,p=new Cesium.Cartesian3,v=new Cesium.PostProcessStage({fragmentShader:s(),uniforms:{u_scanCenterEC:()=>Cesium.Matrix4.multiplyByVector(a.camera.viewMatrix,i,m),u_scanPlaneNormalEC:()=>{const e=Cesium.Matrix4.multiplyByVector(a.camera.viewMatrix,i,m),n=Cesium.Matrix4.multiplyByVector(a.camera.viewMatrix,C,d);return Cesium.Cartesian3.subtract(n,e,p),Cesium.Cartesian3.normalize(p,p),p},u_radius:()=>n*((Date.now()-l)%r)/r,u_scanColor:t}});return a.scene.postProcessStages.add(v),v},s=()=>"\n      uniform sampler2D colorTexture; // 场景的颜色纹理\n      uniform sampler2D depthTexture; // 场景的深度纹理\n      in vec2 v_textureCoordinates; // 纹理坐标\n      uniform vec4 u_scanCenterEC; // 扫描中心（视点坐标系）\n      uniform vec3 u_scanPlaneNormalEC; // 扫描平面的法线（视点坐标系）\n      uniform float u_radius; // 扫描半径\n      uniform vec4 u_scanColor; // 扫描颜色\n      out vec4 fragColor; // 输出的颜色\n\n      // 将纹理坐标转换为视点坐标\n      vec4 toEye(vec2 uv, float depth) {\n        vec2 xy = vec2((uv.x * 2.0 - 1.0), (uv.y * 2.0 - 1.0)); // 将纹理坐标转换为剪裁坐标\n        vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0); // 将剪裁坐标转换为视点坐标\n        posInCamera /= posInCamera.w; // 透视除法\n        return posInCamera; // 返回视点坐标\n      }\n\n      // 将点投影到平面上\n      vec3 pointProjectOnPlane(vec3 planeNormal, vec3 planeOrigin, vec3 point) {\n        vec3 v01 = point - planeOrigin; // 计算从平面原点到点的向量\n        float d = dot(planeNormal, v01); // 计算点到平面的距离\n        return (point - planeNormal * d); // 返回投影点\n      }\n\n      // 获取深度值\n      float getDepth(vec4 depth) {\n        float z_window = czm_unpackDepth(depth); // 解压深度值\n        z_window = czm_reverseLogDepth(z_window); // 反转深度值\n        float near = czm_depthRange.near; // 获取近裁剪面距离\n        float far = czm_depthRange.far; // 获取远裁剪面距离\n        return (2.0 * z_window - near - far) / (far - near); // 计算深度\n      }\n\n      void main() {\n        fragColor = texture(colorTexture, v_textureCoordinates); // 获取当前像素的颜色\n        float depth = getDepth(texture(depthTexture, v_textureCoordinates)); // 获取当前像素的深度\n        vec4 viewPos = toEye(v_textureCoordinates, depth); // 将纹理坐标转换为视点坐标\n        vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC,\n        u_scanCenterEC.xyz, viewPos.xyz); // 将视点坐标投影到扫描平面上\n        float distance = length(prjOnPlane - u_scanCenterEC.xyz); // 计算投影点到扫描中心的距离\n        if (distance < u_radius) { // 如果距离小于扫描半径\n          float intensity = 1.0 - abs(u_radius - distance) / u_radius; // 计算扫描强度\n          intensity = pow(intensity, 18.0); // 增强扫描效果\n          fragColor = mix(fragColor, u_scanColor, intensity); // 混合颜色\n        }\n        fragColor.a /= 2.0; // 调整透明度\n      }\n    ";return n((()=>{r()})),{add:({position:e,scanColor:n,maxRadius:a,duration:r})=>{t.value.push(o(e,n,a,r))},clear:r}}(d),f=()=>{p({position:[120.153576,30.287459,3e4],scanColor:"rgba(0,255,0,1)",maxRadius:1e3,duration:4e3})};return r((()=>{d.camera.setView({destination:Cesium.Cartesian3.fromDegrees(120.153576,30.287459,3e3)})})),(e,n)=>{const a=o("el-button");return i(),s("div",m,[u(a,{type:"primary",onClick:f},{default:c((()=>[l("渲染")])),_:1}),u(a,{type:"primary",onClick:C(v)},{default:c((()=>[l("清除")])),_:1},8,["onClick"])])}}},[["__scopeId","data-v-a33d9fc9"]]);export{d as default};
